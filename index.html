<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Learning Roadmap</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --bg-color: #eef2f9;
            --bg-gradient-dot: #dbe3f0;
            --text-color-primary: #334155;
            --node-topic-bg: #ffffff;
            --node-collapsed-bg: #f0f5ff;
            --node-leaf-bg: #f6ffed;
            --node-leaf-stroke: #d9f7be;
            --node-leaf-text: #3f6212;
            --node-stroke: #dbe3f0;
            --link-stroke: #cbd5e1;
            --hover-stroke: #4f46e5;
            --searched-stroke: #f59e0b;
            --completed-stroke: #22c55e;
            --glass-bg: rgba(255, 255, 255, 0.75);
            --glass-border: rgba(255, 255, 255, 0.25);
            --glass-header-text: #1c1c1e;
            --glass-body-text: #3c3c3e;
            --input-bg: #ffffff;
            --input-border: #d1d5db;
            --input-text: #111827;
            --result-hover-bg: #f0f0f0;
            --button-text: #6b7280;
            --button-text-active: #111827;
            --button-hover-bg: rgba(255, 255, 255, 0.6);
            --button-bg: rgba(255, 255, 255, 0.3);
            --slider-bg: #ffffff;
        }

        html.dark {
            --bg-color: #0d1117;
            --text-color-primary: #f0f6fc;
            --node-topic-bg: #30363d;
            --node-collapsed-bg: #21262d;
            --node-leaf-bg: #034e71;
            --node-leaf-stroke: transparent;
            --node-leaf-text: #f0f6fc;
            --node-stroke: transparent;
            --link-stroke: #8b949e;
            --hover-stroke: #2563eb;
            --searched-stroke: #f59e0b;
            --completed-stroke: #16a34a;
            --glass-bg: rgba(28, 28, 30, 0.75);
            --glass-border: rgba(60, 60, 62, 0.5);
            --glass-header-text: #f5f5f7;
            --glass-body-text: #cccccc;
            --input-bg: #1c1c1e;
            --input-border: #3c3c3e;
            --input-text: #e0e0e0;
            --result-hover-bg: #3c3c3e;
            --button-text: #9ca3af;
            --button-text-active: #ffffff;
            --button-hover-bg: rgba(255, 255, 255, 0.1);
            --button-bg: rgba(255, 255, 255, 0.05);
            --slider-bg: #4b5563;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: var(--bg-color);
            background-image: radial-gradient(var(--bg-gradient-dot) 1px, transparent 1px);
            background-size: 16px 16px;
            transition: background-color 0.3s ease;
        }

        html.dark body {
            background-image: none;
            background-color: #0F0F0F;
        }

        .node .node-content {
            transition: transform 0.2s ease-in-out;
        }
        .node:hover .node-content {
            transform: translateY(-3px);
        }
        .node .node-background {
            cursor: pointer;
            rx: 6;
            stroke-width: 1.5px;
            stroke: var(--node-stroke);
            transition: stroke 0.2s ease-in-out, filter 0.2s ease-in-out, fill 0.3s ease-in-out;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.05));
        }
        .node.topic-node .node-background { fill: var(--node-topic-bg); }
        .node.collapsed-node .node-background { fill: var(--node-collapsed-bg); }
        .node.leaf-node .node-background { fill: var(--node-leaf-bg); stroke: var(--node-leaf-stroke);}

        .node:hover > .node-content > .node-background, .node.node--ancestor-highlight > .node-content > .node-background {
            stroke: var(--hover-stroke);
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.1));
        }

        .node.node--expanded-highlight .node-background {
            stroke: var(--hover-stroke);
            stroke-width: 2.5px;
        }

        .node text {
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            fill: var(--text-color-primary);
            pointer-events: none;
            transition: fill 0.3s ease-in-out;
        }
        .node.leaf-node text {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 10px;
            font-weight: 600;
            fill: var(--node-leaf-text);
        }

        .link {
            fill: none;
            stroke: var(--link-stroke);
            stroke-width: 1px;
            transition: stroke 0.3s ease-in-out, stroke-width 0.3s ease-in-out, opacity 0.4s ease-in-out;
        }
        .link.link--expanded-highlight {
            stroke: var(--hover-stroke);
            stroke-width: 1.5px;
        }
        .link.link--completed {
            stroke: var(--completed-stroke);
            stroke-width: 2px;
        }
        .link.link--flowing {
            stroke-width: 2.5px;
            stroke: url(#flow-gradient);
        }


        .glass-ui {
            background-color: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease-in-out, border-color 0.3s ease-in-out;
        }
        
        .glass-ui.dragging {
            z-index: 1000;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            user-select: none;
        }

        .node.node--searched .node-background {
            stroke: var(--searched-stroke);
            stroke-width: 3px;
            animation: pulse 1.5s infinite;
        }
        
        /* Progress Tracking Styles */
        .node.node--completed {
            opacity: 0.6;
        }
        .node.node--completed .node-background {
            stroke: var(--completed-stroke) !important;
            stroke-width: 2px !important;
        }
        .checkbox-group {
            cursor: pointer;
            transition: opacity 0.2s ease-in-out;
        }
        .checkbox-rect {
            fill: var(--node-topic-bg);
            stroke: var(--link-stroke);
            stroke-width: 1px;
            rx: 3;
        }
        .checkmark {
            stroke: var(--completed-stroke);
            stroke-width: 2.5px;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 20;
            stroke-dashoffset: 20;
            transition: stroke-dashoffset 0.4s ease-in-out;
        }

        .node--completed .checkmark {
            stroke-dashoffset: 0;
        }

        /* Focus Mode Styles */
        .node.unfocused, .link.unfocused {
            opacity: 0.1 !important;
            pointer-events: none;
        }

        @keyframes pulse {
            0% { stroke-opacity: 1; }
            50% { stroke-opacity: 0.4; }
            100% { stroke-opacity: 1; }
        }

        #search-results .result-item {
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            color: var(--glass-body-text);
        }

        #search-results .result-item:hover {
            background-color: var(--result-hover-bg);
        }

        /* Module Switcher Styles */
        #module-switcher {
            display: flex;
            background-color: var(--button-bg);
            border-radius: 0.5rem;
            padding: 2px;
            position: relative;
        }
        #module-switcher button {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 600;
            font-size: 0.875rem;
            color: var(--button-text);
            transition: color 0.3s ease-in-out;
            z-index: 2;
        }
        #module-switcher button.active {
            color: var(--button-text-active);
            font-weight: 700;
        }
        #switch-slider {
            position: absolute;
            top: 2px;
            bottom: 2px;
            border-radius: 0.375rem;
            background-color: var(--slider-bg);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1), 0 1px 2px rgba(0,0,0,0.06);
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), width 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: 1;
        }

        /* Genie Animation Styles */
        @keyframes genie-out {
            0% {
                transform: scale(1) translateY(0);
                opacity: 1;
                clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
            }
            100% {
                transform: scale(0.1) translateY(100vh);
                opacity: 0;
                clip-path: polygon(0 100%, 100% 100%, 100% 100%, 0% 100%);
            }
        }

        @keyframes genie-in {
            0% {
                transform: scale(0.1) translateY(100vh);
                opacity: 0;
                clip-path: polygon(0 100%, 100% 100%, 100% 100%, 0% 100%);
            }
            100% {
                transform: scale(1) translateY(0);
                opacity: 1;
                clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);
            }
        }

        .mindmap-exit-active {
            transform-origin: bottom left;
            animation: genie-out 0.4s forwards cubic-bezier(0.5, 0, 1, 0.5);
        }

        .mindmap-enter-active {
            transform-origin: bottom left;
            animation: genie-in 0.4s forwards cubic-bezier(0, 0.5, 0.5, 1);
        }

    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100">
    <div id="mindmap-container" class="w-screen h-screen"></div>

    <!-- UI Widgets Container -->
    <div id="directory-widget" class="absolute top-4 right-4 z-10 glass-ui rounded-lg max-w-sm w-11/12 sm:w-auto">
        <div id="directory-header" class="p-4 flex justify-between items-center cursor-move">
            <h2 class="text-lg font-semibold text-slate-800" style="color: var(--glass-header-text)">Directory Search</h2>
            <svg id="directory-chevron" class="w-5 h-5 text-gray-600 transform transition-transform duration-300 rotate-180" style="color: var(--glass-body-text)" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
        </div>
        <div id="directory-content" class="text-sm text-slate-600 overflow-hidden transition-all duration-500 ease-in-out" style="max-height: 0px;">
            <div class="px-4 pb-4 border-t" style="border-color: var(--glass-border)">
                <input type="search" id="search-input" placeholder="Search for a command or concept..." class="mt-3 w-full p-2 rounded-md focus:ring-indigo-500 focus:border-indigo-500" style="background-color: var(--input-bg); border: 1px solid var(--input-border); color: var(--input-text);">
                <div id="search-results" class="mt-2 max-h-48 sm:max-h-64 overflow-y-auto"></div>
            </div>
        </div>
    </div>
    
    <div id="ui-controls-container" class="absolute bottom-4 left-4 z-10 glass-ui p-1.5 rounded-lg flex items-center space-x-2">
        <button id="dark-mode-toggle" class="p-2 rounded-md transition-colors" style="--button-hover-bg-light: #ffffff80; --button-hover-bg-dark: #00000033;" onmouseover="this.style.backgroundColor = document.documentElement.classList.contains('dark') ? 'var(--button-hover-bg)' : 'var(--button-hover-bg-light)'" onmouseout="this.style.backgroundColor = 'transparent'">
            <svg id="theme-icon-light" class="w-6 h-6 text-amber-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
            <svg id="theme-icon-dark" class="w-6 h-6 text-slate-200 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
        </button>
        <div id="module-switcher" class="flex items-center">
            <div id="switch-slider"></div>
            <button id="git-btn">Git</button>
            <button id="mysql-btn">MySQL</button>
            <button id="pyspark-btn">PySpark</button>
        </div>
    </div>

    <div id="controls-widget" class="absolute top-24 right-4 lg:top-4 lg:left-4 lg:right-auto z-10 glass-ui rounded-lg">
        <button id="collapse-all-btn" class="px-4 py-2 rounded-lg font-semibold transition-colors" style="color: var(--button-text); background-color: transparent;" onmouseover="this.style.backgroundColor = 'var(--button-hover-bg)'" onmouseout="this.style.backgroundColor = 'transparent'">Collapse All</button>
    </div>

    <!-- Scripts are moved to the end of the body for reliable execution order -->
    <script src="./git_data.js"></script>
    <script src="./mysql_data.js"></script>
    <script src="./pyspark_data.js"></script>
    <script>
    let currentModule = 'git';
    let isAnimating = false;
    let currentTransform = null; // Variable to store zoom state across module switches
    let isSearchPanelOpen = true; // Variable to store search panel state
    let searchHandler = null; // To hold the reference to the current search event listener
    let isFocusModeActive = false;

    // This function sets up all persistent UI controls and should only be run once.
    function initializeGlobalUI() {
        
        function makeDraggable(widget, handle) {
            if (!widget) return;
            let offsetX, offsetY, isDragging = false;
            let hasDragged = false;
            const dragHandle = handle || widget;

            dragHandle.style.cursor = 'move';

            const onDragStart = (e) => {
                 // Prevent dragging from starting only on text inputs.
                if (e.target.tagName === 'INPUT') return;
                
                if (e.type !== 'touchstart') e.preventDefault(); 
                isDragging = true;
                hasDragged = false;
                widget.classList.add('dragging');
                
                const rect = widget.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                offsetX = clientX - rect.left;
                offsetY = clientY - rect.top;
                
                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('touchmove', onDragMove, { passive: false });
                document.addEventListener('mouseup', onDragEnd, { once: true });
                document.addEventListener('touchend', onDragEnd, { once: true });
            };

            const onDragMove = (e) => {
                if (!isDragging) return;
                hasDragged = true;
                if (e.type === 'touchmove') e.preventDefault();
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                let newLeft = clientX - offsetX;
                let newTop = clientY - offsetY;
                
                const rect = widget.getBoundingClientRect();
                newLeft = Math.max(8, Math.min(newLeft, window.innerWidth - rect.width - 8));
                newTop = Math.max(8, Math.min(newTop, window.innerHeight - rect.height - 8));
                
                widget.style.left = `${newLeft}px`;
                widget.style.top = `${newTop}px`;
                widget.style.right = 'auto';
                widget.style.bottom = 'auto';
            };

            const onDragEnd = () => {
                isDragging = false;
                widget.classList.remove('dragging');
                document.removeEventListener('mousemove', onDragMove);
                document.removeEventListener('touchmove', onDragMove);
            };

            dragHandle.addEventListener('mousedown', onDragStart);
            dragHandle.addEventListener('touchstart', onDragStart, { passive: false });

            dragHandle.addEventListener('click', e => {
                if (hasDragged) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
        }

        makeDraggable(document.getElementById('directory-widget'), document.getElementById('directory-header'));
        makeDraggable(document.getElementById('controls-widget'));
        
        const themeToggleBtn = document.getElementById('dark-mode-toggle');
        const lightIcon = document.getElementById('theme-icon-light');
        const darkIcon = document.getElementById('theme-icon-dark');
        
        const directoryHeader = document.getElementById('directory-header');
        const directoryContent = document.getElementById('directory-content');
        const directoryChevron = document.getElementById('directory-chevron');

        const applyTheme = (theme) => {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
                lightIcon.classList.add('hidden');
                darkIcon.classList.remove('hidden');
                localStorage.theme = 'dark';
            } else {
                document.documentElement.classList.remove('dark');
                lightIcon.classList.remove('hidden');
                darkIcon.classList.add('hidden');
                localStorage.theme = 'light';
            }
        };

        themeToggleBtn.addEventListener('click', () => {
            applyTheme(localStorage.theme === 'dark' ? 'light' : 'dark');
        });
        
        // --- FIX for Mobile Panel Expansion ---
        // More robust logic for toggling the search panel.
        const toggleSearchPanel = () => {
            // If it's open or opening, close it. `max-height` will be 'auto' or a pixel value.
            if (isSearchPanelOpen) {
                isSearchPanelOpen = false;
                
                // If max-height is 'auto', we first need to set it to the element's current height
                // so the transition can work from a specific pixel value.
                if (directoryContent.style.maxHeight === 'auto') {
                    directoryContent.style.maxHeight = directoryContent.scrollHeight + 'px';
                }

                // In the next animation frame, set max-height to 0 to trigger the closing animation.
                requestAnimationFrame(() => {
                    directoryContent.style.maxHeight = '0px';
                    directoryChevron.classList.add('rotate-180');
                });
            } else { // If it's closed, open it.
                isSearchPanelOpen = true;
                
                // Set max-height to the content's full height to trigger the opening animation.
                directoryContent.style.maxHeight = directoryContent.scrollHeight + 'px';
                directoryChevron.classList.remove('rotate-180');
                
                // After the transition finishes, set max-height to 'auto'. This allows the panel
                // to dynamically resize if its content (e.g., search results) changes.
                const onTransitionEnd = () => {
                    if(isSearchPanelOpen) { // Check it wasn't closed again during the animation
                       directoryContent.style.maxHeight = 'auto';
                    }
                    directoryContent.removeEventListener('transitionend', onTransitionEnd);
                };
                directoryContent.addEventListener('transitionend', onTransitionEnd);
            }
        };

        directoryHeader.addEventListener('click', (e) => {
             if(e.target.closest('svg')) {
                toggleSearchPanel();
            }
        });


        applyTheme(localStorage.theme === 'dark' ? 'dark' : 'light');
        setupModuleSwitcher(currentModule);
    }

    // This code runs after the HTML and the data scripts have been loaded.
    const main = () => {
        const params = new URLSearchParams(window.location.search);
        const moduleParam = params.get('module') || 'git';
        currentModule = moduleParam;
        
        const data = (currentModule === 'mysql') ? window.mysqlData : (currentModule === 'pyspark') ? window.pysparkData : window.gitData;


        if (data) {
            document.title = data.name;
            initializeGlobalUI(); // Sets up ALL UI controls once
            initializeMindmap(data); // Renders the mindmap
        } else {
             console.error(`Data for module not found: ${currentModule}. Ensure ${currentModule}_data.js is present and loaded correctly.`);
             const container = document.getElementById('mindmap-container');
             if(container) {
                container.innerHTML = `<div class="flex items-center justify-center h-screen text-center p-4">
                    <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                      <strong class="font-bold">Error:</strong>
                      <span class="block sm:inline">Could not load data for the '${currentModule}' module. Please ensure <strong>${currentModule}_data.js</strong> is in the same folder as index.html and is not blocked.</span>
                    </div>
                 </div>`;
             }
        }
    };

    function setupModuleSwitcher(activeModule) {
        const gitBtn = document.getElementById('git-btn');
        const mysqlBtn = document.getElementById('mysql-btn');
        const pysparkBtn = document.getElementById('pyspark-btn');
        const slider = document.getElementById('switch-slider');

        const setActiveStyles = (module) => {
            let targetBtn;
            if (module === 'mysql') targetBtn = mysqlBtn;
            else if (module === 'pyspark') targetBtn = pysparkBtn;
            else targetBtn = gitBtn;

            gitBtn.classList.remove('active');
            mysqlBtn.classList.remove('active');
            pysparkBtn.classList.remove('active');
            
            if (targetBtn) {
                slider.style.width = targetBtn.offsetWidth + 'px';
                slider.style.transform = `translateX(${targetBtn.offsetLeft}px)`;
                targetBtn.classList.add('active');
            }
        };

        // Set initial slider position after a short delay to ensure correct rendering
        setTimeout(() => setActiveStyles(activeModule), 100);

        gitBtn.addEventListener('click', () => {
            if (currentModule !== 'git' && !isAnimating) {
                setActiveStyles('git');
                switchModule('git');
            }
        });

        mysqlBtn.addEventListener('click', () => {
            if (currentModule !== 'mysql' && !isAnimating) {
                setActiveStyles('mysql');
                switchModule('mysql');
            }
        });
        
        pysparkBtn.addEventListener('click', () => {
            if (currentModule !== 'pyspark' && !isAnimating) {
                setActiveStyles('pyspark');
                switchModule('pyspark');
            }
        });
    }

    function switchModule(newModule) {
        if (isAnimating || newModule === currentModule) return;
        isAnimating = true;
        
        // Reset the search panel on tab switch
        const searchInput = document.getElementById('search-input');
        const searchResults = document.getElementById('search-results');
        if (searchInput) searchInput.value = '';
        if (searchResults) searchResults.innerHTML = '';

        // Reset the zoom transform so the new module starts with a fresh view
        currentTransform = null; 

        const container = d3.select("#mindmap-container");
        const oldSvg = container.select("svg");

        if (oldSvg.node()) {
            oldSvg.classed("mindmap-exit-active", true);

            setTimeout(() => {
                oldSvg.remove();
                loadNewModule(newModule, container);
            }, 400); // Match animation duration
        } else {
            loadNewModule(newModule, container);
        }
    }

    function loadNewModule(newModule, container) {
        const newData = (newModule === 'mysql') ? window.mysqlData : (currentModule === 'pyspark') ? window.pysparkData : window.gitData;
        document.title = newData.name;
        initializeMindmap(newData);

        const newSvg = container.select("svg");
        newSvg.classed("mindmap-enter-active", true);
        
        currentModule = newModule;
        const url = new URL(window.location);
        url.searchParams.set('module', newModule);
        window.history.pushState({}, '', url);

        setTimeout(() => {
            newSvg.classed("mindmap-enter-active", false);
            isAnimating = false;
        }, 400); // Match animation duration
    }

    function generateNodeId(d) {
        // Create a stable ID based on depth and name
        return `${d.depth}-${d.data.name.replace(/\s+/g, '-')}`;
    }

    function saveProgress(root, module) {
        try {
            const completedNodes = [];
            root.each(d => {
                if (d.data.completed) {
                    completedNodes.push(generateNodeId(d));
                }
            });
            localStorage.setItem(`${module}-progress`, JSON.stringify(completedNodes));
        } catch (e) {
            console.error("Failed to save progress to localStorage:", e);
        }
    }

    function loadProgress(root, module) {
        try {
            const savedProgress = localStorage.getItem(`${module}-progress`);
            if (savedProgress) {
                const completedNodeIds = new Set(JSON.parse(savedProgress));
                root.each(d => {
                    if (completedNodeIds.has(generateNodeId(d))) {
                        d.data.completed = true;
                    }
                });
            }
        } catch (e) {
            console.error("Failed to load progress from localStorage:", e);
        }
    }


    function initializeMindmap(data) {
        // --- D3 Mind Map Visualization ---
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Clear container before appending a new SVG
        d3.select("#mindmap-container").html("");

        const svg = d3.select("#mindmap-container").append("svg")
            .attr("width", width)
            .attr("height", height)
            .on("dblclick", (event) => {
                if (isFocusModeActive) {
                    event.stopPropagation();
                    exitFocusMode();
                }
            });

        const g = svg.append("g");

        const zoom = d3.zoom()
            .scaleExtent([0.1, 2])
            .on("zoom", (event) => {
                currentTransform = event.transform; // Store the transform on every zoom/pan
                g.attr("transform", event.transform);
            });

        svg.call(zoom);

        const treemap = d3.tree().nodeSize([40, 20]);

        let root = d3.hierarchy(data, d => d.children);
        const allNodes = root.descendants();
        
        loadProgress(root, currentModule);

        root.x0 = height / 2;
        root.y0 = 0;
        
        root.children.forEach(collapse);
        
        let i = 0;
        update(root);

        function collapse(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = null;
            }
        }
        
        function update(source) {
            const duration = 400; // Increased duration for better animation visibility
            const treeData = treemap(root);
            
            const nodes = treeData.descendants();
            const links = treeData.descendants().slice(1);
            
            let maxLabelLength = 0;
             nodes.forEach(d => {
                maxLabelLength = Math.max(d.data.name.length, maxLabelLength);
            });

            nodes.forEach(d => { d.y = d.depth * (maxLabelLength * 9) });


            // --- Nodes ---
            const node = g.selectAll("g.node")
                .data(nodes, d => d.id || (d.id = ++i));

            const nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .style("opacity", 1e-6) // Start nodes as transparent
                .on("click", click)
                .on("dblclick", (event, d) => {
                    event.stopPropagation();
                    if (isFocusModeActive) {
                        exitFocusMode();
                    } else {
                        enterFocusMode(event, d);
                    }
                })
                .on("mouseover", function(event, d) {
                    const ancestors = d.ancestors();
                    const ancestorIds = new Set(ancestors.map(node => node.id));

                    g.selectAll('g.node')
                        .filter(node_d => ancestorIds.has(node_d.id))
                        .classed('node--ancestor-highlight', true)
                        .raise();

                    g.selectAll('path.link')
                        .filter(link_d => ancestorIds.has(link_d.id) && link_d.parent && ancestorIds.has(link_d.parent.id))
                        .classed('link--hover', true)
                        .raise();
                })
                .on("mouseout", function(event, d) {
                    g.selectAll('.node--ancestor-highlight').classed('node--ancestor-highlight', false);
                    g.selectAll('.link--hover').classed('link--hover', false);
                });
            
            const nodeContent = nodeEnter.append('g')
                .attr('class', 'node-content');

            nodeContent.append("rect")
                .attr("class", "node-background")
                .attr("width", 0)
                .attr("height", 0);
            
            nodeContent.append("text")
                .attr("dy", ".35em")
                .text(d => d.data.name);

            const checkboxGroup = nodeContent.append('g')
                .attr('class', 'checkbox-group')
                .on('click', toggleComplete);

            // Add a larger, invisible rectangle to act as a generous click target.
            checkboxGroup.append('rect')
                .attr('width', 24)
                .attr('height', 24)
                .attr('x', -4)
                .attr('y', -4)
                .style('fill', 'transparent');

            checkboxGroup.append('rect')
                .attr('class', 'checkbox-rect')
                .attr('width', 16)
                .attr('height', 16);
            
            checkboxGroup.append('path')
                .attr('class', 'checkmark')
                .attr('d', 'M4 8l2.5 2.5L12 5');

            nodeContent.append('path')
                .attr('class', 'edge-marker')
                .attr('d', 'M0,-5L6,0L0,5')
                .style('fill', '#94a3b8')
                .style('opacity', 0);

            const nodeUpdate = nodeEnter.merge(node);
            
            nodeUpdate
                .classed('leaf-node', d => !d.children && !d._children)
                .classed('collapsed-node', d => !!d._children)
                .classed('topic-node', d => !!d.children)
                .classed('node--expanded-highlight', d => d.depth > 0 && !!d.children)
                .classed('node--completed', d => d.data.completed);
            
            nodeUpdate.transition()
                .duration(duration)
                .attr("transform", d => `translate(${d.y},${d.x})`)
                .style("opacity", 1) // Fade nodes in
                .delay((d, i) => d.parent === source ? i * 20 : 0);
            
            nodeUpdate.each(function(d) {
                const textNode = d3.select(this).select("text").node();
                if (!textNode) return;
                const bbox = textNode.getBBox();
                
                const checkboxWidth = 16;
                const horizontalPadding = 12;
                const internalSpacing = 8;
                const rectHeight = 26;

                const rectWidth = horizontalPadding + checkboxWidth + internalSpacing + bbox.width + horizontalPadding;
                d.rectWidth = rectWidth;

                d3.select(this).select(".node-background").transition()
                    .duration(duration)
                    .attr("width", rectWidth)
                    .attr("height", rectHeight)
                    .attr("x", 0)
                    .attr("y", -rectHeight / 2);

                const checkboxX = horizontalPadding;
                d3.select(this).select(".checkbox-group")
                    .transition()
                    .duration(duration)
                    .attr('transform', `translate(${checkboxX}, -8)`);
                
                const textX = checkboxX + checkboxWidth + internalSpacing;
                d3.select(this).select("text").transition()
                    .duration(duration)
                    .attr("x", textX)
                    .attr("text-anchor", "start");
            });
            
            nodeUpdate.select('.checkmark').style('opacity', d => d.data.completed ? 1 : 0);
            
            nodeUpdate.select('.edge-marker')
                .transition()
                .duration(duration)
                .attr('transform', d => `translate(${d.rectWidth}, 0)`)
                .style('opacity', d => (d.children || d._children) ? 1 : 0);

            const nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .style("opacity", 1e-6) // Fade nodes out
                .remove();
            
            nodeExit.select("rect").attr("width", 0).attr("height", 0);
            
            const link = g.selectAll("path.link")
                .data(links, d => d.id);

            const linkEnter = link.enter().insert("path", "g")
                .attr("class", "link")
                .attr('d', d => {
                    const o = {x: source.x0, y: source.y0}
                    return diagonal(o, o)
                });
            
            linkEnter.each(function() {
                const path = d3.select(this);
                const totalLength = this.getTotalLength();
                if(totalLength > 0) {
                    path.attr("stroke-dasharray", `${totalLength} ${totalLength}`)
                        .attr("stroke-dashoffset", totalLength)
                        .transition()
                        .duration(duration)
                        .delay(duration / 2) 
                        .attr("stroke-dashoffset", 0);
                }
            });
                
            const linkUpdate = linkEnter.merge(link);

            linkUpdate.classed('link--expanded-highlight', d => d.depth > 0 && !!d.children)
                .classed('link--completed', d => d.data.completed);

            linkUpdate.transition()
                .duration(duration)
                .attr('d', d => diagonal(d, d.parent));
            
            link.exit().transition()
                .duration(duration)
                .attr('d', d => {
                    const o = {x: source.x, y: source.y}
                    return diagonal(o, o)
                })
                .remove();

            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }
        
        function click(event, d) {
            if (event.defaultPrevented) return;
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            update(d);
            centerNode(d);
        }

        function setCompletionStatus(node, status) {
            node.data.completed = status;
            const children = node.children || node._children;
            if (children) {
                children.forEach(child => setCompletionStatus(child, status));
            }
        }

        function checkAndUpdateParents(node) {
            if (!node.parent) {
                return;
            }
            const parent = node.parent;
            const siblings = parent.children || parent._children;
            if (!siblings) {
                return;
            }
            const allChildrenCompleted = siblings.every(child => child.data.completed);
            if (parent.data.completed === allChildrenCompleted) {
                return;
            }
            parent.data.completed = allChildrenCompleted;
            checkAndUpdateParents(parent);
        }

        function toggleComplete(event, d) {
            event.stopPropagation();
            const newStatus = !d.data.completed;
            setCompletionStatus(d, newStatus);
            checkAndUpdateParents(d);
            saveProgress(root, currentModule);
            update(root);
        }

        function enterFocusMode(event, d) {
            event.stopPropagation();
            isFocusModeActive = true;
            
            const focusBranchIds = new Set();
            d.ancestors().forEach(node => focusBranchIds.add(node.id));
            d.descendants().forEach(node => focusBranchIds.add(node.id));

            g.selectAll('.node, .link').classed('unfocused', true);
            
            g.selectAll('.node')
                .filter(node => focusBranchIds.has(node.id))
                .classed('unfocused', false);
            
            g.selectAll('.link')
                .filter(link => focusBranchIds.has(link.id) && link.parent && focusBranchIds.has(link.parent.id))
                .classed('unfocused', false);
        }

        function exitFocusMode() {
            isFocusModeActive = false;
            g.selectAll('.unfocused').classed('unfocused', false);
        }

        function diagonal(s, d) {
            if (!d || typeof d.y === 'undefined' || typeof d.x === 'undefined' || !s || typeof s.y === 'undefined' || typeof s.x === 'undefined') {
                return "M0,0C0,0,0,0,0,0";
            }
            const parentRightX = d.y + (d.rectWidth || 0);
            const childLeftX = s.y;
            
            return `M ${parentRightX} ${d.x}
                    C ${(parentRightX + childLeftX) / 2} ${d.x},
                      ${(parentRightX + childLeftX) / 2} ${s.x},
                      ${childLeftX} ${s.x}`;
        }
        
        if (currentTransform) {
            svg.call(zoom.transform, currentTransform);
        } else {
            const initialTransform = d3.zoomIdentity.translate(100, height / 2);
            svg.call(zoom.transform, initialTransform);
            currentTransform = initialTransform;
        }

        const collapseAllBtn = document.getElementById('collapse-all-btn');

        collapseAllBtn.addEventListener('click', () => {
            root.children.forEach(collapse);
            update(root);
        });

        const searchInput = document.getElementById('search-input');
        const searchResults = document.getElementById('search-results');
        
        if (searchHandler) {
            searchInput.removeEventListener('input', searchHandler);
        }

        searchHandler = () => {
            const searchTerm = searchInput.value.toLowerCase().trim();
            searchResults.innerHTML = '';
            g.selectAll("g.node").classed("node--searched", false);

            if (searchTerm.length >= 2) {
                const foundNodes = allNodes.filter(d => d.data.name.toLowerCase().includes(searchTerm));

                if (foundNodes.length === 0) {
                    searchResults.innerHTML = `<div class="p-2 text-slate-500">No results found.</div>`;
                } else {
                    foundNodes.forEach(d => {
                        const resultItem = document.createElement('div');
                        resultItem.className = 'result-item';
                        resultItem.textContent = d.data.name;
                        resultItem.addEventListener('click', () => {
                            expandToNode(d);
                            update(root);

                            setTimeout(() => {
                                g.selectAll("g.node").classed("node--searched", false);
                                g.selectAll("g.node")
                                    .filter(nodeData => nodeData.id === d.id)
                                    .classed("node--searched", true);
                                centerNode(d);
                            }, 300);
                        });
                        searchResults.appendChild(resultItem);
                    });
                }
            }
            
            // --- REVISED FIX for Panel Expansion ---
            // If the panel is open, explicitly update its max-height to animate the size change
            // as new search results are added or removed.
            if (isSearchPanelOpen) {
                const directoryContent = document.getElementById('directory-content');
                directoryContent.style.maxHeight = directoryContent.scrollHeight + 'px';

                // After the transition, set max-height to 'auto' so it can continue to
                // resize dynamically if the user keeps typing.
                const onTransitionEnd = () => {
                    if (isSearchPanelOpen) { // Only set to auto if it hasn't been closed
                        directoryContent.style.maxHeight = 'auto';
                    }
                    directoryContent.removeEventListener('transitionend', onTransitionEnd);
                };
                directoryContent.addEventListener('transitionend', onTransitionEnd, { once: true });
            }
        };
        
        searchInput.addEventListener('input', searchHandler);
        
        // --- FIX for Mobile Panel Expansion ---
        // Use the new, more robust logic to set the initial state of the panel.
        const directoryContent = document.getElementById('directory-content');
        const directoryChevron = document.getElementById('directory-chevron');
        
        const openPanelInitially = () => {
            directoryChevron.classList.remove('rotate-180');
            directoryContent.style.maxHeight = directoryContent.scrollHeight + 'px';
            const onTransitionEnd = () => {
                if(isSearchPanelOpen) {
                   directoryContent.style.maxHeight = 'auto';
                }
                directoryContent.removeEventListener('transitionend', onTransitionEnd);
            };
            directoryContent.addEventListener('transitionend', onTransitionEnd);
        };

        if (isSearchPanelOpen) {
            // Use a timeout to ensure the DOM is fully rendered and scrollHeight is accurate.
            setTimeout(openPanelInitially, 50);
        } else {
            directoryContent.style.maxHeight = '0px';
            directoryChevron.classList.add('rotate-180');
        }

        function expandToNode(d) {
            let current = d;
            while (current.parent) {
                if (current.parent._children) {
                    current.parent.children = current.parent._children;
                    current.parent._children = null;
                }
                current = current.parent;
            }
        }

        function centerNode(d) {
            const scale = currentTransform ? currentTransform.k : 1;
            const x = -d.y * scale + width / 3;
            const y = -d.x * scale + height / 2;
            const transform = d3.zoomIdentity.translate(x, y).scale(scale);

            svg.transition()
                .duration(750)
                .call(zoom.transform, transform);
        }
    }
    
    // Initialize the application
    main();
    </script>
</body>
</html>

